Package wsml2pyDatalog;

Helpers
    all	=	[ 0x0 .. 0xffff ];
    escape_char	=	'\';
    basechar	=	[ 0x0041 .. 0x005A ] | [ 0x0061 .. 0x007A ];
    ideographic	=	[ 0x4E00 .. 0x9FA5 ] | 0x3007 | [ 0x3021 .. 0x3029 ];
    letter	=	basechar | ideographic;
    digit	=	[ 0x0030 .. 0x0039 ];
    combiningchar	=	[ 0x0300 .. 0x0345 ] | [ 0x0360 .. 0x0361 ] | [ 0x0483 .. 0x0486 ];
    extender	=	0x00B7 | 0x02D0 | 0x02D1 | 0x0387 | 0x0640 | 0x0E46 | 0x0EC6 | 0x3005 | [ 0x3031 .. 0x3035 ] | [ 0x309D .. 0x309E ] | [ 0x30FC .. 0x30FE ];
    alphanum	=	digit | letter;
    hexdigit	=	[ '0' .. '9' ] | [ 'A' .. 'F' ];
    not_escaped_namechar	=	letter | digit | '_' | combiningchar | extender;
    escaped_namechar	=	'.' | '-' | not_escaped_namechar;
    namechar	=	( escape_char escaped_namechar ) | not_escaped_namechar;
    reserved	=	'/' | '?' | '#' | '[' | ']' | ';' | ':' | '@' | '&' | '=' | '+' | '$' | ',';
    mark	=	'-' | '_' | '.' | '!' | '~' | '*' | ''' | '(' | ')';
    escaped	=	'%' hexdigit hexdigit;
    unreserved	=	letter | digit | mark;
    scheme	=	letter ( letter | digit | '+' | '-' | '.' )*;
    port	=	digit*;
    idomainlabel	=	alphanum ( ( alphanum | '-' )* alphanum )?;
    dec_octet	=	digit | ( [ 0x31 .. 0x39 ] digit ) | ( '1' digit digit ) | ( '2' [ 0x30 .. 0x34 ] digit ) | ( '25' [ 0x30 .. 0x35 ] );
    ipv4address	=	dec_octet '.' dec_octet '.' dec_octet '.' dec_octet;
    h4	=	hexdigit hexdigit? hexdigit? hexdigit?;
    ls32	=	( h4 ':' h4 ) | ipv4address;
    ipv6address	=	( ( h4 ':' )* h4 )? '::' ( h4 ':' )* ls32 | ( ( h4 ':' )* h4 )? '::' h4 | ( ( h4 ':' )* h4 )? '::';
    ipv6reference	=	'[' ipv6address ']';
    ucschar	=	[ 0xA0 .. 0xD7FF ] | [ 0xF900 .. 0xFDCF ] | [ 0xFDF0 .. 0xFFEF ];
    iunreserved	=	unreserved | ucschar;
    ipchar	=	iunreserved | escaped | ';' | ':' | '@' | '&' | '=' | '+' | '$' | ',';
    isegment	=	ipchar*;
    ipath_segments	=	isegment ( '/' isegment )*;
    iuserinfo	=	( iunreserved | escaped | ';' | ':' | '&' | '=' | '+' | '$' | ',' )*;
    iqualified	=	( '.' idomainlabel )* '.' ?;
    ihostname	=	idomainlabel iqualified;
    ihost	=	( ipv6reference | ipv4address | ihostname )?;
    iauthority	=	( iuserinfo '@' )? ihost ( ':' port )?;
    iabs_path	=	'/' ipath_segments;
    inet_path	=	'//' iauthority ( iabs_path )?;
    irel_path	=	ipath_segments;
    ihier_part	=	inet_path | iabs_path | irel_path;
    iprivate	=	[ 0xE000 .. 0xF8FF ];
    iquery	=	( ipchar | iprivate | '/' | '?' )*;
    ifragment	=	( ipchar | '/' | '?' )*;
    iri_f	=	scheme ':' ihier_part ( '?' iquery )? ( '#' ifragment )?;
    absolute_iri	=	scheme ':' ihier_part ( '?' iquery )?;
    relative_iri	=	ihier_part ( '?' iquery )? ( '#' ifragment )?;
    iric	=	reserved | iunreserved | escaped;
    iri_reference	=	iri_f | relative_iri;
    tab	=	9;
    cr	=	13;
    lf	=	10;
    eol	=	cr lf | cr | lf;
    squote	=	''';
    dquote	=	'"';
    not_cr_lf	=	[ all - [ cr+ lf ] ];
    escaped_char	=	escape_char all;
    not_escape_char_not_dquote	=	[ all - [ '"' + escape_char ] ];
    string_content	=	escaped_char | not_escape_char_not_dquote;
    long_comment_content	=	[ all - '/' ] | [ all - '*' ] '/';
    long_comment	=	'/*' long_comment_content* '*/';
    begin_comment	=	'//' | 'comment ';
    short_comment	=	begin_comment not_cr_lf* eol;
    comment	=	short_comment | long_comment;
    blank	=	( ' ' | tab | eol )+;
    qmark	=	'?';
    luridel	=	'_"';
    ruridel	=	'"';

Tokens
    t_blank	=	blank;
    t_comment	=	comment;
    comma	=	',';
    endpoint	=	'.' blank;
    lpar	=	'(';
    rpar	=	')';
    lbracket	=	'[';
    rbracket	=	']';
    lbrace	=	'{';
    rbrace	=	'}';
    hash	=	'#';
    t_and	=	'and';
    t_or	=	'or';
    t_implies	=	'implies' | '->';
    t_implied_by	=	'impliedBy' | '<-';
    t_equivalent	=	'equivalent' | '<->';
    t_implied_by_lp	=	':-';
    t_constraint	=	'!-';
    t_not	=	'neg' | 'naf';
    t_exists	=	'exists';
    t_forall	=	'forall';
    t_univfalse	=	'false';
    t_univtrue	=	'true';
    gt	=	'>';
    lt	=	'<';
    gte	=	'>=';
    lte	=	'=<';
    equal	=	'=';
    unequal	=	'!=';
    add_op	=	'+';
    sub_op	=	'-';
    star	=	'*';
    div_op	=	'/';
    t_assumption	=	'assumption';
    t_axiom	=	'axiom';
    t_capability	=	'capability';
    t_choreography	=	'choreography';
    t_concept	=	'concept';
    t_definedby	=	'definedBy';
    t_effect	=	'effect';
    t_endnfp	=	'endNonFunctionalProperties' | 'endnfp';
    t_ggmediator	=	'ggMediator';
    t_goal	=	'goal';
    t_hasvalue	=	'hasValue';
    t_impliestype	=	'impliesType';
    t_importontology	=	'importsOntology';
    t_instance	=	'instance';
    t_interface	=	'interface';
    t_inverseof	=	'inverseOf';
    t_memberof	=	'memberOf';
    t_namespace	=	'namespace';
    t_nfp	=	'nonFunctionalProperties' | 'nfp';
    t_oftype	=	'ofType';
    t_ontology	=	'ontology';
    t_oomediator	=	'ooMediator';
    t_orchestration	=	'orchestration';
    t_postcondition	=	'postcondition';
    t_precondition	=	'precondition';
    t_reflexive	=	'reflexive';
    t_relation	=	'relation';
    t_relation_instance	=	'relationInstance';
    t_sharedvariable	=	'sharedVariables';
    t_source	=	'source';
    t_subconcept	=	'subConceptOf';
    t_subrelation	=	'subRelationOf';
    t_symmetric	=	'symmetric';
    t_target	=	'target';
    t_transitive	=	'transitive';
    t_usemediator	=	'usesMediator';
    t_useservice	=	'usesService';
    t_webservice	=	'webService';
    t_wgmediator	=	'wgMediator';
    t_wsmlvariant	=	'wsmlVariant';
    t_wwmediator	=	'wwMediator';
    variable	=	qmark alphanum+;
    anonymous	=	'_#';
    nb_anonymous	=	'_#' digit+;
    pos_integer	=	digit+;
    pos_decimal	=	digit+ '.' digit+;
    string	=	dquote string_content* dquote;
    full_iri	=	luridel iri_reference ruridel;
    name	=	( letter | '_' ) namechar*;

Ignored Tokens
    t_blank, t_comment;

Productions
    wsml = wsmlvariant? namespace? definition*;
    wsmlvariant	= t_wsmlvariant full_iri;
    namespace = t_namespace prefixdefinitionlist;
    sharedvardef = t_sharedvariable variablelist;
    capability = t_capability id? header* sharedvardef? pre_post_ass_or_eff*;
    goal = t_goal id? header* capability? interfaces*;
    webservice = t_webservice id? header* capability? interfaces*;
    definition = {goal}	goal | {ontology} ontology | {webservice} webservice | {mediator} mediator;
    prefixdefinitionlist = {defaultns} full_iri | {prefixdefinitionlist} lbrace prefixdefinition moreprefixdefinitions* rbrace;
    prefixdefinition = {namespacedef} name full_iri | {default}	full_iri;
    moreprefixdefinitions = comma prefixdefinition;
    header = {nfp} nfp | {usesmediator} usesmediator | {importsontology} importsontology;
    usesmediator = t_usemediator idlist;
    importsontology	= t_importontology idlist;
    nfp	= t_nfp attributevalue* t_endnfp;
    mediator = {oomediator}	oomediator | {ggmediator} ggmediator | {wgmediator}	wgmediator | {wwmediator} wwmediator;
    oomediator = t_oomediator id? nfp? importsontology? sources? target? use_service?;
    ggmediator = t_ggmediator id? header* sources? target? use_service?;
    wgmediator = t_wgmediator id? header* source? target? use_service?;
    wwmediator = t_wwmediator id? header* source? target? use_service?;
    use_service	= t_useservice id;
    source = t_source id;
    msources = t_source lbrace id moreids* rbrace;
    sources	= {single} source | {multiple} msources;
    target = t_target id;
    pre_post_ass_or_eff	= {precondition} t_precondition axiomdefinition | {postcondition} t_postcondition axiomdefinition | {assumption} t_assumption axiomdefinition |	{effect} t_effect axiomdefinition;
    minterfaces	= t_interface lbrace id moreids* rbrace;
    interface = t_interface id? header* choreography? orchestration?;
    interfaces = {single} interface | {multiple} minterfaces;
    choreography = t_choreography id;
    orchestration =	t_orchestration id;
    ontology = t_ontology id? header* ontology_element*;
    ontology_element = {concept} concept | {instance} instance | {relation}	relation | {relationinstance} relationinstance | {axiom} axiom;
    concept	= t_concept id superconcept? nfp? attribute*;
    superconcept = t_subconcept idlist;
    att_type = {open_world} t_oftype | {closed_world} t_impliestype;
    attribute = id attributefeature* att_type cardinality? idlist nfp?;
    cardinality	= lpar pos_integer cardinality_number? rpar;
    cardinality_number = {finite_cardinality}	pos_integer | {infinite_cardinality} star;
    attributefeature = {transitive}	t_transitive | {symmetric} t_symmetric | {inverse} t_inverseof lpar id rpar | {reflexive} t_reflexive;
    instance = t_instance id? memberof? nfp? attributevalue*;
    memberof = t_memberof idlist;
    attributevalue = id t_hasvalue valuelist;
    relation = t_relation id arity? paramtyping? superrelation? nfp?;
    paramtype = att_type idlist;
    paramtyping	= lpar paramtype moreparamtype* rpar;
    moreparamtype = comma paramtype;
    superrelation = t_subrelation idlist;
    arity = div_op pos_integer;
    relationinstance = t_relation_instance [name]: id? [relation]: id lpar value morevalues* rpar nfp?;
    axiom =	t_axiom axiomdefinition;
    axiomdefinition	= {use_axiom}	id | {nfp_axiom} id? nfp | {defined_axiom} id? nfp? log_definition;
    log_definition = t_definedby log_expr+;
    log_expr = {lp_rule} [head]: expr t_implied_by_lp [body]: expr endpoint | {constraint} t_constraint expr endpoint| {other_expression} expr endpoint;
    expr = {implication} expr imply_op disjunction | {disjunction} disjunction;
    disjunction	= {conjunction}	conjunction | disjunction t_or conjunction;
    conjunction = {subexpr}	subexpr | conjunction t_and subexpr;
    subexpr	= {negated}	t_not subexpr | {simple} simple | {complex} lpar expr rpar | {quantified} quantified;
    quantified = quantifier_key variablelist lpar expr rpar;
    simple = {molecule} molecule | {comparison} comparison | {atom} term;
    molecule = {concept_molecule_preferred}	term attr_specification? cpt_op termlist | {concept_molecule_nonpreferred} term cpt_op termlist attr_specification | {attribute_molecule} term attr_specification;
    attr_specification = lbracket attr_rel_list rbracket;
    attr_rel_list = {attr_relation} attr_relation | attr_rel_list comma attr_relation;
    attr_relation = {attr_def} term attr_def_op termlist  | {attr_val} term t_hasvalue termlist;
    comparison = [left]: term comp_op [right]: term;
    functionsymbol = {parametrized} id lpar terms? rpar | {math} lpar mathexpr math_op term rpar;
    mathexpr = {sub} mathexpr math_op term | term;
    comp_op = {gt} gt | {lt} lt | {gte} gte | {lte} lte | {equal} equal | {unequal} unequal;
    cpt_op = {memberof} t_memberof | {subconceptof} t_subconcept;
    quantifier_key = {forall} t_forall | {exists} t_exists;
    attr_def_op = {oftype} t_oftype | {impliestype} t_impliestype;
    imply_op = {implies} t_implies | {impliedby} t_implied_by | {equivalent} t_equivalent;
    math_op = {add} add_op | {sub} sub_op | {mul} star | {div} div_op;
    prefix = name hash;
    sqname = {any} prefix? name | {relation} prefix t_relation | {source} prefix t_source;
    iri = {iri} full_iri | {sqname} sqname;
    id = {iri} iri | {anonymous} anonymous | {universal_truth} t_univtrue | {universal_falsehood} t_univfalse;
    idlist = {id} id | {idlist}	lbrace id moreids* rbrace;
    moreids = comma id;
    value = {datatype} functionsymbol | {term} id | {numeric} number | {string} string;
    valuelist = {term}	value | {valuelist} lbrace value morevalues* rbrace;
    morevalues = comma value;
    term = {data} value | {var} variable | {nb_anonymous} nb_anonymous;
    terms = {term} term | terms comma term;
    termlist = {term} term | lbrace terms rbrace;
    variables = {variable} variable | variables comma variable;
    variablelist = {variable} variable | {variable_list} lbrace variables rbrace;
    integer = sub_op? pos_integer;
    decimal = sub_op? pos_decimal;
    number = {integer} integer | {decimal} decimal;